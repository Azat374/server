==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\.env.example ====
#SQLALCHEMY_DATABASE_URI=sqlite:///database/math_checker.db
DB_DB_SECRET_KEY=23e629b053aeda6ff423b58a99f861cecd1670e05af7bb9ea55757f419e2a0dcdab40e36e772fbf55ef0ba5533527e4360ad2c25b740336049a9d30667ca126c
DATABASE_PATH = os.path.join(BASE_DIR, "database", "math_checker.db")
SQLALCHEMY_DATABASE_URI = "sqlite:///" + DATABASE_PATH



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\app.py ====
from flask import Flask
from flask_cors import CORS
from config import Config
from models import db
from utils.Auth.auth import auth_bp
from tasks import tasks_bp
from solutions import solutions_bp
from reports import reports_bp
from profile import profile_bp
from solution_integral import solution_integral_bp
app = Flask(__name__)
app.config.from_object(Config)
CORS(app)

db.init_app(app)

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(tasks_bp)
app.register_blueprint(solutions_bp)
app.register_blueprint(reports_bp)
app.register_blueprint(profile_bp)
app.register_blueprint(solution_integral_bp)
# –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü, –µ—Å–ª–∏ –∏—Ö –µ—â—ë –Ω–µ—Ç
with app.app_context():
    db.create_all()

if __name__ == "__main__":
    app.run(debug=True)



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\checker.py ====
import sympy as sp

def safe_sympify(expr):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤ sympy-—Ñ–æ—Ä–º–∞—Ç."""
    try:
        if expr == "LIMIT":
            # –ï—Å–ª–∏ –ø—Ä–∏—Ö–æ–¥–∏—Ç LIMIT, —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —á—Ç–æ-—Ç–æ
            # –ù–æ –ª—É—á—à–µ –≤–æ–æ–±—â–µ –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –µ–≥–æ –∫–∞–∫ expr :)
            return sp.Integer(0)  # –∑–∞–≥–ª—É—à–∫–∞
        expr = expr.replace("e^{", "exp(").replace(r"\ln", "log")
        return sp.sympify(expr)
    except Exception as e:
        raise ValueError(f"–û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è '{expr}': {e}")

def check_algebraic_step(prev_expr_str, curr_expr_str, tolerance=1e-6):
    try:
        # –ï—Å–ª–∏ –≤ prev_expr_str = "LIMIT", –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
        if prev_expr_str == "LIMIT":
            return {"is_correct": True, "error_type": None, "hint": "LIMIT –∫–∞–∫ –ø—Ä–µ–¥—ã–¥—É—â–∏–π —à–∞–≥ –ø—Ä–æ–ø—É—â–µ–Ω."}

        prev_expr = sp.simplify(safe_sympify(prev_expr_str))
        curr_expr = sp.simplify(safe_sympify(curr_expr_str))
        if prev_expr.equals(curr_expr):
            return {"is_correct": True, "error_type": None, "hint": ""}
        # –î–æ–ø.—á–∏—Å–ª–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        for val in [1, 2, 3]:
            if abs(prev_expr.subs({'x': val}) - curr_expr.subs({'x': val})) > tolerance:
                return {
                    "is_correct": False,
                    "error_type": "algebraic_error",
                    "hint": "–û—à–∏–±–∫–∞ –≤ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è—Ö. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∏–ª–∏ –≤—ã–Ω–µ—Å–µ–Ω–∏–µ –º–Ω–æ–∂–∏—Ç–µ–ª—è."
                }
        return {"is_correct": True, "error_type": None, "hint": ""}
    except Exception as e:
        return {"is_correct": False, "error_type": "parse_error", "hint": f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {str(e)}"}

def check_limit(last_expr_str, expected_value_str):
    try:
        x = sp.Symbol('x')
        last_expr = safe_sympify(last_expr_str)
        computed_limit = sp.limit(last_expr, x, sp.oo)
        expected_value = safe_sympify(expected_value_str)
        if sp.simplify(computed_limit - expected_value) == 0:
            return {"is_correct": True, "computed_limit": computed_limit, "error_type": None, "hint": ""}
        else:
            return {
                "is_correct": False,
                "computed_limit": computed_limit,
                "error_type": "limit_error",
                "hint": f"–û–∂–∏–¥–∞–µ–º—ã–π –ø—Ä–µ–¥–µ–ª: {expected_value}"
            }
    except Exception as e:
        return {
            "is_correct": False,
            "error_type": "limit_parse_error",
            "hint": f"–û—à–∏–±–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–µ–¥–µ–ª–∞: {str(e)}"
        }



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\config.py ====
import os

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATABASE_PATH = os.path.join(BASE_DIR, "database", "math_checker.db")

# –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
print("DATABASE_PATH:", DATABASE_PATH)  # üîπ –í—ã–≤–æ–¥ –ø—É—Ç–∏ –≤ –∫–æ–Ω—Å–æ–ª—å

SQLALCHEMY_DATABASE_URI = f"sqlite:///{DATABASE_PATH}"
SQLALCHEMY_TRACK_MODIFICATIONS = False
import os
from dotenv import load_dotenv

load_dotenv()

BASE_DIR = os.path.abspath(os.path.dirname(__file__))
DATABASE_PATH = os.path.join(BASE_DIR, "database", "math_checker.db")

class Config:
    DB_SECRET_KEY = os.getenv('DB_SECRET_KEY', '23e629b053aeda6ff423b58a99f861cecd1670e05af7bb9ea55757f419e2a0dcdab40e36e772fbf55ef0ba5533527e4360ad2c25b740336049a9d30667ca126c')
    SQLALCHEMY_DATABASE_URI = f"sqlite:///{DATABASE_PATH}"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    DEBUG = True



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\models.py ====
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    username = db.Column(db.String(100), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    bio = db.Column(db.Text, default="")
    image = db.Column(db.String(300), default="")
    role = db.Column(db.String(50), default="student")  # –∏–ª–∏ "admin"
    chat_history = db.Column(db.Text)  # –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å JSON –∫–∞–∫ —Å—Ç—Ä–æ–∫—É

    solutions = db.relationship('Solution', backref='user', lazy=True)

class Task(db.Model):
    __tablename__ = 'tasks'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    expression = db.Column(db.String(500), nullable=False)  # –∏—Å—Ö–æ–¥–Ω–æ–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    limitVar = db.Column(db.String(50), nullable=False)      # –Ω–∞–ø—Ä–∏–º–µ—Ä "x->‚àû"
    expected_value = db.Column(db.String(100), nullable=False)
    category = db.Column(db.String(50), nullable=False)  # –Ω–∞–ø—Ä–∏–º–µ—Ä "–∞–ª–≥–µ–±—Ä–∞", "–≥–µ–æ–º–µ—Ç—Ä–∏—è"
    solutions = db.relationship('Solution', backref='task', lazy=True)

class Solution(db.Model):
    __tablename__ = 'solutions'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    task_id = db.Column(db.Integer, db.ForeignKey('tasks.id'), nullable=False)
    status = db.Column(db.String(50), default="in_progress")  # in_progress, completed, error
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    steps = db.relationship('Step', backref='solution', lazy=True)

class Step(db.Model):
    __tablename__ = 'steps'
    id = db.Column(db.Integer, primary_key=True)
    solution_id = db.Column(db.Integer, db.ForeignKey('solutions.id'), nullable=False)
    step_number = db.Column(db.Integer, nullable=False)
    input_expr = db.Column(db.String(500), nullable=False)
    is_correct = db.Column(db.Boolean, default=True)
    error_type = db.Column(db.String(100))
    hint = db.Column(db.String(300))




==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\profile.py ====
import cloudinary
from flask import Blueprint, request, jsonify
from models import db, User

profile_bp = Blueprint('profile', __name__, url_prefix='/profile')

@profile_bp.route("/<username>", methods=["GET"])
def get_user(username):
    user = User.query.filter_by(username=username).first()
    if not user:
        return jsonify({"error": "User not found"}), 404
    print(user)
    user_data = {
        "username": user.username,
        "firstname": user.firstname,
        "lastname": user.lastname,
        "email": user.email,
        "bio": user.bio or "",
        "image": user.image or ""
    }
    return jsonify({"user": user_data}), 200


@profile_bp.route('/<username>', methods=['PUT'])
def update_user(username):
    data = request.json
    updated_user = User.update_user_settings(username, data)
    if not updated_user:
        return jsonify({"error": "User not found"}), 404
    
    user_data = {
        "username": updated_user.username,
        "firstname": updated_user.firstname,
        "lastname": updated_user.lastname,
        "email": updated_user.email,
        "bio": updated_user.bio or "",
        "image": updated_user.image or ""
    }
    db.session.commit()
    return jsonify({"user": user_data}), 200

@profile_bp.route('/upload-image', methods=['POST'])
def upload_image():
    if 'image' not in request.files:
        return jsonify({"error": "No image file provided"}), 400
    
    file = request.files['image']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    
    try:
        upload_result = cloudinary.uploader.upload(file)
        image_url = upload_result.get('secure_url')
        return jsonify({"imageUrl": image_url}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\reports.py ====
import os
import logging
import io
from datetime import datetime
from flask import Blueprint, request, send_file, jsonify
from models import db, Solution, User, Task, Step
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

reports_bp = Blueprint('reports', __name__, url_prefix='/api/reports')

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∞–∑–æ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
font_regular_path = os.path.join(BASE_DIR, "fonts", "DejaVuSans.ttf")
font_bold_path = os.path.join(BASE_DIR, "fonts", "DejaVuSans-Bold.ttf")
logging.info("–ü—É—Ç—å –∫ DejaVuSans: %s", font_regular_path)
logging.info("–ü—É—Ç—å –∫ DejaVuSans-Bold: %s", font_bold_path)

if not os.path.exists(font_regular_path) or not os.path.exists(font_bold_path):
    logging.error("–§–∞–π–ª —à—Ä–∏—Ñ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º —à—Ä–∏—Ñ—Ç–æ–≤.")
else:
    pdfmetrics.registerFont(TTFont('DejaVuSans', font_regular_path))
    pdfmetrics.registerFont(TTFont('DejaVuSans-Bold', font_bold_path))

def wrap_text(text, max_width, c_obj, font, font_size):
    """
    –†–∞–∑–±–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–∫, —á—Ç–æ–±—ã —à–∏—Ä–∏–Ω–∞ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏ –Ω–µ –ø—Ä–µ–≤—ã—à–∞–ª–∞ max_width.
    """
    words = text.split()
    lines = []
    current_line = ""
    for word in words:
        test_line = f"{current_line} {word}".strip() if current_line else word
        if c_obj.stringWidth(test_line, font, font_size) <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return lines

@reports_bp.route('/pdf', methods=['POST'])
def generate_pdf_report():
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç PDF-–æ—Ç—á–µ—Ç —Å –∏—Å—Ç–æ—Ä–∏–µ–π —Ä–µ—à–µ–Ω–∏–π —Å—Ç—É–¥–µ–Ω—Ç–æ–≤, —Ä–∞–∑–±–æ—Ä–æ–º –æ—à–∏–±–æ–∫ –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏.
    –û–∂–∏–¥–∞–µ—Ç—Å—è JSON —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: period (–Ω–∞–ø—Ä–∏–º–µ—Ä, "2024-01-01:2024-02-01"),
    task_id –∏ student_id (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ).
    """
    try:
        data = request.json
        period = data.get("period")  # —Ñ–æ—Ä–º–∞—Ç "YYYY-MM-DD:YYYY-MM-DD"
        task_id = data.get("task_id")
        student_id = data.get("student_id")

        query = Solution.query
        if period:
            try:
                start_str, end_str = period.split(":")
                start_date = datetime.strptime(start_str, "%Y-%m-%d")
                end_date = datetime.strptime(end_str, "%Y-%m-%d")
                # –†–∞—Å—à–∏—Ä—è–µ–º –∫–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞ –¥–æ –∫–æ–Ω—Ü–∞ –¥–Ω—è
                end_date = end_date.replace(hour=23, minute=59, second=59)
                query = query.filter(Solution.created_at >= start_date, Solution.created_at <= end_date)
            except Exception as e:
                logging.error("–û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ –ø–µ—Ä–∏–æ–¥–∞: %s", e)
                return jsonify({"message": "Invalid period format. Use YYYY-MM-DD:YYYY-MM-DD"}), 400
        if task_id:
            query = query.filter(Solution.task_id == task_id)
        if student_id:
            query = query.filter(Solution.user_id == student_id)

        solutions = query.all()

        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter
        margin = 50
        max_text_width = width - 2 * margin
        y = height - margin

        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —à–∞–ø–∫–∏ –Ω–∞ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
        def draw_header(c_obj):
            c_obj.setFont("DejaVuSans-Bold", 20)
            c_obj.drawCentredString(width / 2, height - margin + 20, "–û—Ç—á–µ—Ç –ø–æ —Ä–µ—à–µ–Ω–∏—è–º —Å—Ç—É–¥–µ–Ω—Ç–æ–≤")
            c_obj.line(margin, height - margin + 10, width - margin, height - margin + 10)

        draw_header(c)
        y -= 40
        c.setFont("DejaVuSans", 12)

        if not solutions:
            wrapped = wrap_text("–ù–µ—Ç —Ä–µ—à–µ–Ω–∏–π –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞ –∏–ª–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤.", max_text_width, c, "DejaVuSans", 12)
            for line in wrapped:
                c.drawString(margin, y, line)
                y -= 15
        else:
            for sol in solutions:
                if y < margin + 120:
                    c.showPage()
                    draw_header(c)
                    y = height - margin - 30

                # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–µ—à–µ–Ω–∏—è
                solution_header = (
                    f"–†–µ—à–µ–Ω–∏–µ ID: {sol.id} | –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {sol.user.username} | "
                    f"–ó–∞–¥–∞—á–∞: {sol.task.title} | –°—Ç–∞—Ç—É—Å: {sol.status} | –î–∞—Ç–∞: {sol.created_at.strftime('%Y-%m-%d %H:%M')}"
                )
                header_lines = wrap_text(solution_header, max_text_width, c, "DejaVuSans-Bold", 12)
                c.setFont("DejaVuSans-Bold", 12)
                for line in header_lines:
                    c.drawString(margin, y, line)
                    y -= 15
                y -= 5

                c.setFont("DejaVuSans", 11)
                # –í—ã–≤–æ–¥ —à–∞–≥–æ–≤ —Ä–µ—à–µ–Ω–∏—è
                for step in sorted(sol.steps, key=lambda s: s.step_number):
                    step_text = f"–®–∞–≥ {step.step_number}: {step.input_expr} ‚Äî " + ("–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ" if step.is_correct else "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")
                    if not step.is_correct:
                        step_text += f" (–û—à–∏–±–∫–∞: {step.error_type}; –ü–æ–¥—Å–∫–∞–∑–∫–∞: {step.hint})"
                    step_lines = wrap_text(step_text, max_text_width - 20, c, "DejaVuSans", 11)
                    for line in step_lines:
                        c.drawString(margin + 20, y, line)
                        y -= 12
                    if y < margin + 50:
                        c.showPage()
                        draw_header(c)
                        y = height - margin - 30

                y -= 10
                c.line(margin, y, width - margin, y)
                y -= 20

        c.showPage()
        c.save()
        buffer.seek(0)
        return send_file(buffer, as_attachment=True, download_name="report.pdf", mimetype="application/pdf")
    except Exception as e:
        logging.error("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞: %s", e)
        return jsonify({"message": "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç", "details": str(e)}), 500



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\requirements.txt ====
Flask
flask-cors
pymongo
python-dotenv
gunicorn
requests
google-generativeai
cloudinary
Flask-SQLAlchemy
reportlab
werkzeug
PyJWT
sympy
latex2sympy2


==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\routes.py ====
from flask import Flask, request, jsonify
from flask_cors import CORS
from models import db, Task, Solution, Step
from checker import check_step
from utils.Auth.auth import signup_handler, signin_handler
import cloudinary
import cloudinary.uploader
from models import User

app = Flask(__name__)
app.config.from_object("config.Config")
db.init_app(app)
CORS(app)

@app.route("/tasks", methods=["GET"])
def get_tasks():
    tasks = Task.query.all()
    return jsonify([{"id": t.id, "title": t.title, "description": t.description, "category": t.category} for t in tasks])

@app.route("/tasks/<int:task_id>/start", methods=["POST"])
def start_solution(task_id):
    solution = Solution(task_id=task_id, status="in_progress")
    db.session.add(solution)
    db.session.commit()
    return jsonify({"solution_id": solution.id})

@app.route("/solutions/<int:solution_id>/check_step", methods=["POST"])
def check_solution_step(solution_id):
    data = request.json
    step_number = data.get("step_number")
    prev_expr = data.get("prev_expr", "")
    curr_expr = data.get("curr_expr", "")

    result = check_step(prev_expr, curr_expr)
    
    step = Step(solution_id=solution_id, step_number=step_number,
                input_expr=curr_expr, is_correct=result["is_correct"],
                error_type=result["error_type"], hint=result["hint"])
    
    db.session.add(step)
    db.session.commit()

    return jsonify(result)

@app.route("/solutions/<int:solution_id>/finish", methods=["POST"])
def finish_solution(solution_id):
    solution = Solution.query.get(solution_id)
    solution.status = "completed"
    db.session.commit()
    return jsonify({"message": "–†–µ—à–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!"})


if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    app.run(debug=True)




==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\solutions.py ====
import logging
import sympy as sp
from flask import Blueprint, request, jsonify
from models import db, Task, Solution, Step
from flask_cors import cross_origin
from latex2sympy2 import latex2sympy  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è LaTeX –≤ Sympy
from typing import List
import re
solutions_bp = Blueprint('solutions', __name__, url_prefix='/api/solutions')

def normalize_steps_with_limit(steps: List[str]) -> List[str]:
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —à–∞–≥–æ–≤, —É–¥–∞–ª—è–µ—Ç \\lim_{...} –∏–∑ LaTeX –≤—ã—Ä–∞–∂–µ–Ω–∏–π –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –º–∞—Ä–∫–µ—Ä LIMIT –ø–µ—Ä–µ–¥ —à–∞–≥–æ–º,
    –≤ –∫–æ—Ç–æ—Ä–æ–º –ª–∏–º–∏—Ç –±–æ–ª—å—à–µ –Ω–µ —É–∫–∞–∑–∞–Ω.
    """
    normalized = []
    inserted_limit = False

    lim_pattern = re.compile(r"\\lim_\{[^\}]+\}")

    for i, step in enumerate(steps):
        has_limit = bool(lim_pattern.search(step))

        if has_limit:
            # –£–¥–∞–ª—è–µ–º —Å–∞–º—É –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é \lim_{x\to ...}
            cleaned_step = lim_pattern.sub("", step).strip()
            normalized.append(cleaned_step)
        else:
            if not inserted_limit:
                normalized.append("LIMIT")
                inserted_limit = True
            normalized.append(step)

    return normalized



def safe_sympify(expr):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç LaTeX-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç sympy —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫,
    –∏—Å–ø–æ–ª—å–∑—É—è –±–∏–±–ª–∏–æ—Ç–µ–∫—É latex2sympy2."""
    try:
        if expr.strip().upper() == "LIMIT":
            # –ï—Å–ª–∏ –ø–æ–ª—É—á–µ–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ LIMIT, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä (–∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –≤—ã—á–∏—Å–ª—è–µ–º –∑–¥–µ—Å—å)
            return sp.Integer(0)
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º LaTeX-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ sympy —Å –ø–æ–º–æ—â—å—é latex2sympy2
        sympy_expr = latex2sympy(expr)
        return sympy_expr
    except Exception as e:
        logging.error(f"Expression parsing error: '{expr}' - {str(e)}")
        raise ValueError(f"Cannot parse expression '{expr}': {str(e)}")

def check_algebraic_step(prev_expr_str, curr_expr_str, tolerance=1e-10):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è —à–∞–≥–∞–º–∏."""
    try:
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –¥–ª—è –º–∞—Ä–∫–µ—Ä–∞ LIMIT
        if prev_expr_str.strip().upper() == "LIMIT" or curr_expr_str.strip().upper() == "LIMIT":
            return {"is_correct": True, "error_type": None, "hint": None}

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ safe_sympify –∏ —É–ø—Ä–æ—â–∞–µ–º –∏—Ö
        prev_expr = sp.simplify(safe_sympify(prev_expr_str))
        curr_expr = sp.simplify(safe_sympify(curr_expr_str))
        
        # –ï—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã, —à–∞–≥ –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω
        if prev_expr.equals(curr_expr):
            return {"is_correct": True, "error_type": None, "hint": None}
        
        # –ï—Å–ª–∏ –Ω–µ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã ‚Äì –ø—Ä–æ–≤–µ—Ä—è–µ–º —á–∏—Å–ª–µ–Ω–Ω–æ —Å –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–æ–π
        x = sp.Symbol('x')
        test_values = [1, 2, 3, 5, 10, 100]
        
        for val in test_values:
            try:
                prev_val = float(prev_expr.subs({x: val}))
                curr_val = float(curr_expr.subs({x: val}))
                
                if not (sp.isinf(prev_val) or sp.isinf(curr_val) or sp.isnan(prev_val) or sp.isnan(curr_val)):
                    if abs(prev_val - curr_val) > tolerance:
                        return {
                            "is_correct": False,
                            "error_type": "algebraic_error",
                            "hint": f"–í–∞—à —à–∞–≥ –Ω–µ–≤–µ—Ä–µ–Ω. –î–ª—è x={val}, –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ = {prev_val:.6f}, —Ç–µ–∫—É—â–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ = {curr_val:.6f}"
                        }
            except Exception:
                continue
                
        return {"is_correct": True, "error_type": None, "hint": None}
    except Exception as e:
        logging.error(f"Error checking step: {str(e)}")
        return {
            "is_correct": False, 
            "error_type": "parse_error", 
            "hint": f"–û—à–∏–±–∫–∞ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏: {str(e)}"
        }

def check_limit(expr_str, var_str, limit_point):
    """–í—ã—á–∏—Å–ª—è–µ—Ç –ø—Ä–µ–¥–µ–ª –≤—ã—Ä–∞–∂–µ–Ω–∏—è."""
    try:
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
        expr = safe_sympify(expr_str)
        var = sp.Symbol(var_str)
        print(f"–ü—Ä–µ–¥–µ–ª –¥–ª—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è: {expr}, –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è: {var}, —Ç–æ—á–∫–∞ –ø—Ä–µ–¥–µ–ª–∞: {limit_point}")

        

        if limit_point == "oo" or limit_point == "‚àû" or limit_point == "infinity":
            limit_result = sp.limit(expr, var, sp.oo)
        elif limit_point == "-oo" or limit_point == "-‚àû" or limit_point == "-infinity":
            limit_result = sp.limit(expr, var, -sp.oo)
        else:
            limit_result = sp.limit(expr, var, limit_point)
        print(expr, var, limit_point)

        return {
            "is_correct": True,
            "computed_limit": limit_result,
            "error_type": None,
            "hint": None
        }
    except Exception as e:
        logging.error(f"Error computing limit: {str(e)}")
        return {
            "is_correct": False,
            "computed_limit": None,
            "error_type": "limit_error",
            "hint": f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–µ–ª–∞: {str(e)}"
        }

def compare_limit_values(student_result, expected_result):
    """–°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–µ–¥–µ–ª–∞ —Å—Ç—É–¥–µ–Ω—Ç–∞ —Å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –æ—Å–æ–±—ã–µ —Å–ª—É—á–∞–∏."""
    try:
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å
        if (sp.oo == student_result and sp.oo == expected_result) or \
           (-sp.oo == student_result and -sp.oo == expected_result):
            return True
            
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –æ–±—ã—á–Ω—ã—Ö —á–∏—Å–µ–ª
        diff = sp.simplify(student_result - expected_result)
        return diff.is_zero
    except Exception:
        # –ï—Å–ª–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
        return str(student_result) == str(expected_result)

@solutions_bp.route('/check', methods=['POST'])
@cross_origin()
def check_solution():
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–ª–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ, —Ä–∞–∑–±–∏—Ç–æ–µ –Ω–∞ —à–∞–≥–∏.
    –û–∂–∏–¥–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç JSON:
    {
        "taskId": <task_id>,
        "steps": [
            "—à–∞–≥ 1", "—à–∞–≥ 2", ..., "LIMIT", "–æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç"
        ]
    }
    """
    data = request.json
    logging.info(f"Received solution check request: {data}")
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
    if not data or "taskId" not in data or "steps" not in data:
        return jsonify({"error": "Invalid request format"}), 400
        
    task_id = data["taskId"]
    steps_bad = data["steps"]
    
    if not isinstance(steps_bad, list) or len(steps_bad) < 2:
        return jsonify({
            "success": False,
            "errors": [{"step": 1, "error": "–†–µ—à–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å–æ—Å—Ç–æ—è—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º –∏–∑ –¥–≤—É—Ö —à–∞–≥–æ–≤"}]
        }), 400
        
    steps = normalize_steps_with_limit(steps_bad)
    # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"error": "Task not found"}), 404
        
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
    errors = []
    algebraic_steps = []
    limit_index = -1
    found_limit = False
    
    # –ü–æ–∏—Å–∫ –º–∞—Ä–∫–µ—Ä–∞ LIMIT –∏ —Å–±–æ—Ä –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö —à–∞–≥–æ–≤
    for i, step in enumerate(steps):
        if step.strip().upper() == "LIMIT":
            found_limit = True
            limit_index = i
            break
        algebraic_steps.append(step)
        
    # –ï—Å–ª–∏ LIMIT –Ω–µ –Ω–∞–π–¥–µ–Ω, –∞ —à–∞–≥–æ–≤ –Ω–µ –º–µ–Ω—å—à–µ –¥–≤—É—Ö, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥ ‚Äì –ø—Ä–µ–¥–µ–ª
    if not found_limit and len(steps) >= 2:
        algebraic_steps = steps[:-1]
        steps.insert(len(steps)-1, "LIMIT")
        limit_index = len(steps) - 2
        found_limit = True
        
    if not algebraic_steps:
        return jsonify({
            "success": False,
            "errors": [{"step": 1, "error": "–ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —à–∞–≥–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç", "hint": "–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —à–∞–≥ –ø–µ—Ä–µ–¥ LIMIT"}]
        }), 400
        
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö —à–∞–≥–æ–≤
    for i in range(len(algebraic_steps) - 1):
        prev_expr = algebraic_steps[i]
        curr_expr = algebraic_steps[i + 1]
        
        try:
            result = check_algebraic_step(prev_expr, curr_expr)
            if not result["is_correct"]:
                errors.append({
                    "step": i + 2,
                    "error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ",
                    "hint": result["hint"] or "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∞–ª–≥–µ–±—Ä—É"
                })
        except Exception as e:
            errors.append({
                "step": i + 2,
                "error": "–û—à–∏–±–∫–∞ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏",
                "hint": f"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å: {str(e)}"
            })
            
    # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Ä–µ—à–µ–Ω–∏—è
    user_id = 1  # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    solution = Solution(task_id=task.id, user_id=user_id, status="in_progress")
    db.session.add(solution)
    db.session.flush()  # –ü–æ–ª—É—á–∞–µ–º ID –±–µ–∑ –∫–æ–º–º–∏—Ç–∞
    
    # –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–µ–¥–µ–ª, –µ—Å–ª–∏ –æ—à–∏–±–æ–∫ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ
    computed_limit = None
    if found_limit and not errors:
        try:
            last_algebraic_expr = algebraic_steps[-1]
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –∏ —Ç–æ—á–∫—É –ø—Ä–µ–¥–µ–ª–∞ –∏–∑ –¥–∞–Ω–Ω—ã—Ö –∑–∞–¥–∞—á–∏
            limit_var = "x"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
            limit_point = "oo"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (–±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å)
            
            if task.limitVar:
                parts = task.limitVar.split("‚Üí")
                if len(parts) == 2:
                    limit_var = parts[0].strip()
                    limit_point = parts[1].strip()
            
            limit_result = check_limit(last_algebraic_expr, limit_var, limit_point)
            computed_limit = limit_result["computed_limit"]
            
            if not limit_result["is_correct"]:
                errors.append({
                    "step": limit_index + 1,
                    "error": "–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–µ–ª–∞",
                    "hint": limit_result["hint"]
                })
                
            # –ï—Å–ª–∏ –ø–æ—Å–ª–µ LIMIT —É–∫–∞–∑–∞–Ω –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç ‚Äì —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –µ–≥–æ —Å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–º –ø—Ä–µ–¥–µ–ª–æ–º
            if limit_index < len(steps) - 1 and not errors:
                student_answer = steps[-1]
                try:
                    # –°–ø–µ—Ü–æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å
                    if student_answer.strip() in ["\\infty", "\\infinity", "‚àû"]:
                        student_result = sp.oo
                    elif student_answer.strip() in ["-\\infty", "-\\infinity", "-‚àû"]:
                        student_result = -sp.oo
                    else:
                        student_result = sp.simplify(safe_sympify(student_answer))
                    
                    expected_result = computed_limit
                    
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–ª—É—á—à–µ–Ω–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
                    if not compare_limit_values(student_result, expected_result):
                        errors.append({
                            "step": len(steps),
                            "error": "–ù–µ–≤–µ—Ä–Ω—ã–π –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç",
                            "hint": f"–í–∞—à –æ—Ç–≤–µ—Ç –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–º –ø—Ä–µ–¥–µ–ª–æ–º. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {expected_result}"
                        })
                except Exception as e:
                    errors.append({
                        "step": len(steps),
                        "error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç",
                        "hint": f"–û—à–∏–±–∫–∞ –≤ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–º –æ—Ç–≤–µ—Ç–µ: {str(e)}"
                    })
        except Exception as e:
            logging.error(f"Limit calculation error: {str(e)}")
            errors.append({
                "step": limit_index + 1,
                "error": "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø—Ä–µ–¥–µ–ª–∞",
                "hint": f"–û—à–∏–±–∫–∞: {str(e)}"
            })
            
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —à–∞–≥–æ–≤ —Ä–µ—à–µ–Ω–∏—è
    for i, step in enumerate(steps):
        is_correct = len(errors) == 0
        step_record = Step(
            solution_id=solution.id,
            step_number=i + 1,
            input_expr=step,
            is_correct=is_correct,
            error_type=None if is_correct else "error",
            hint=""
        )
        db.session.add(step_record)
        
    # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Ä–µ—à–µ–Ω–∏—è
    if errors:
        solution.status = "error"
    else:
        solution.status = "completed"
        
    db.session.commit()
    
    # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
    if errors:
        return jsonify({
            "success": False,
            "errors": errors,
            "solution_id": solution.id
        })
        
    return jsonify({
        "success": True,
        "message": "–†–µ—à–µ–Ω–∏–µ –≤–µ—Ä–Ω–æ–µ.",
        "solution_id": solution.id
    })


==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\solution_integral.py ====
import logging
import sympy as sp
from flask import Blueprint, request, jsonify
from models import db, Task, Solution, Step
from flask_cors import cross_origin
from latex2sympy2 import latex2sympy  # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ LaTeX –≤ Sympy
from typing import List
import re

solution_integral_bp = Blueprint('solution_integral', __name__, url_prefix='/api/solutions')

def safe_sympify(expr):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç LaTeX-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ –æ–±—ä–µ–∫—Ç sympy, –∏—Å–ø–æ–ª—å–∑—É—è latex2sympy2."""
    print(f"Parsed expression: {expr}")
    try:
        
        sympy_expr = latex2sympy(expr)
        
        return sympy_expr
    except Exception as e:
        logging.error(f"Expression parsing error: '{expr}' - {str(e)}")
        raise ValueError(f"Cannot parse expression '{expr}': {str(e)}")

def check_algebraic_step(prev_expr_str, curr_expr_str, tolerance=1e-10):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è —à–∞–≥–∞–º–∏.
    –ï—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ —à–∞–≥–æ–≤ —Ä–∞–≤–µ–Ω "LIMIT", –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç—Å—è.
    """
    try:
        if prev_expr_str.strip().upper() == "LIMIT" or curr_expr_str.strip().upper() == "LIMIT":
            return {"is_correct": True, "error_type": None, "hint": None}
        prev_expr = sp.simplify(safe_sympify(prev_expr_str))
        curr_expr = sp.simplify(safe_sympify(curr_expr_str))
        if prev_expr.equals(curr_expr):
            return {"is_correct": True, "error_type": None, "hint": None}
        x = sp.Symbol('x')
        test_values = [1, 2, 3, 5, 10, 100]
        for val in test_values:
            try:
                prev_val = float(prev_expr.subs({x: val}))
                curr_val = float(curr_expr.subs({x: val}))
                if not (sp.isinf(prev_val) or sp.isinf(curr_val) or sp.isnan(prev_val) or sp.isnan(curr_val)):
                    if abs(prev_val - curr_val) > tolerance:
                        return {
                            "is_correct": False,
                            "error_type": "algebraic_error",
                            "hint": f"–î–ª—è x={val}: –ø—Ä–µ–¥—ã–¥—É—â–µ–µ = {prev_val:.6f}, —Ç–µ–∫—É—â–µ–µ = {curr_val:.6f}"
                        }
            except Exception:
                continue
        return {"is_correct": True, "error_type": None, "hint": None}
    except Exception as e:
        logging.error(f"Error checking step: {str(e)}")
        return {"is_correct": False, "error_type": "parse_error", "hint": f"–û—à–∏–±–∫–∞: {str(e)}"}

def check_integral_solution_final(final_solution_str, integrand_str, var_str="x"):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –ø–æ –∏–Ω—Ç–µ–≥—Ä–∞–ª—É.
    –î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä—É–µ—Ç –∫–æ–Ω–µ—á–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –µ–≥–æ —Å –∏–Ω—Ç–µ–≥—Ä–∞–Ω—Ç–æ–º.
    """
    try:
        final_expr = sp.simplify(safe_sympify(final_solution_str))
        integrand_expr = sp.simplify(safe_sympify(integrand_str))
        var = sp.Symbol(var_str)
        
        diff_expr = sp.simplify(final_expr - integrand_expr)
        # –ï—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å —Ä–∞–≤–Ω–∞ –Ω—É–ª—é –∏–ª–∏ —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–º (–≤–æ–∑–º–æ–∂–Ω–æ, –∫–æ–Ω—Å—Ç–∞–Ω—Ç–æ–π), —Å—á–∏—Ç–∞–µ–º —à–∞–≥ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º
        if diff_expr == 0 or diff_expr.is_number:
            return {"is_correct": True, "error_type": None, "hint": None}
        else:
            return {
                "is_correct": False,
                "error_type": "integral_error",
                "hint": f"–ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –≤–∞—à–µ–≥–æ –æ—Ç–≤–µ—Ç–∞ —Ä–∞–≤–Ω–∞ {sp.pretty(final_expr)}, –∞ –∏–Ω—Ç–µ–≥—Ä–∞–Ω—Ç ‚Äî {sp.pretty(integrand_expr)}"
            }
    except Exception as e:
        logging.error(f"Error checking integral solution: {str(e)}")
        return {"is_correct": False, "error_type": "parse_error", "hint": f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {str(e)}"}

@solution_integral_bp.route('/check-integral', methods=['POST'])
@cross_origin()
def check_integral_solution():
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ä–µ—à–µ–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏.
    –û–∂–∏–¥–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç JSON:
    {
        "taskId": <task_id>,
        "phiSteps": [
            {
                "label": "\\varphi_0(x)",
                "steps": ["—à–∞–≥ 1", "—à–∞–≥ 2", ...]
            },
            { ... }  // –≤–æ–∑–º–æ–∂–Ω–æ, –Ω–µ—Å–∫–æ–ª—å–∫–æ œÜ-—Ñ—É–Ω–∫—Ü–∏–π
        ],
        "finalSolution": "LaTeX —Å—Ç—Ä–æ–∫–∏ —Å –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–º –æ—Ç–≤–µ—Ç–æ–º"
    }
    """
    data = request.json
    logging.info(f"Received integral solution check request: {data}")

    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if not data or "taskId" not in data or "phiSteps" not in data or "finalSolution" not in data:
        return jsonify({"error": "Invalid request format"}), 400

    task_id = data["taskId"]
    phi_steps = data["phiSteps"]
    final_solution = data["finalSolution"]

    if not isinstance(phi_steps, list) or len(phi_steps) < 1:
        return jsonify({
            "success": False,
            "errors": [{"phiIndex": 0, "error": "–î–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ œÜ-—Ñ—É–Ω–∫—Ü–∏—è —Å —à–∞–≥–∞–º–∏"}]
        }), 400

    # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É –∏–∑ –ë–î (–æ–∂–∏–¥–∞–µ—Ç—Å—è, —á—Ç–æ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á –≤ –º–æ–¥–µ–ª–∏ –ø–æ–ª–µ integrand —Ö—Ä–∞–Ω–∏—Ç—Å—è, –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ task.equation)
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"error": "Task not found"}), 404

    errors = []  # –°–ø–∏—Å–æ–∫ –æ—à–∏–±–æ–∫ –¥–ª—è œÜ-—Ñ—É–Ω–∫—Ü–∏–π –∏ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —à–∞–≥–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π œÜ-—Ñ—É–Ω–∫—Ü–∏–∏
    for phi_index, phi in enumerate(phi_steps):
        steps = phi.get("steps")
        if not isinstance(steps, list) or len(steps) < 1:
            errors.append({
                "phiIndex": phi_index,
                "error": "–§—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —à–∞–≥",
                "hint": "–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —à–∞–≥–∏ –¥–ª—è –¥–∞–Ω–Ω–æ–π œÜ-—Ñ—É–Ω–∫—Ü–∏–∏"
            })
            continue
        # –ï—Å–ª–∏ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ —à–∞–≥–∞ ‚Äì –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π
        if len(steps) > 1:
            for i in range(len(steps) - 1):
                result = check_algebraic_step(steps[i], steps[i + 1])
                if not result["is_correct"]:
                    errors.append({
                        "phiIndex": phi_index,
                        "stepIndex": i + 1,
                        "error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ",
                        "hint": result["hint"] or "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —à–∞–≥–∏"
                    })

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –ø–æ –∏–Ω—Ç–µ–≥—Ä–∞–ª—É.
    # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ –≤ –∑–∞–¥–∞—á–µ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á —Ö—Ä–∞–Ω–∏—Ç—Å—è –∏–Ω—Ç–µ–≥—Ä–∞–Ω—Ç –≤ –ø–æ–ª–µ task.equation
    if not final_solution.strip():
        errors.append({
            "phiIndex": -1,
            "error": "–û–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç",
            "hint": "–í–≤–µ–¥–∏—Ç–µ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –ø–æ –∏–Ω—Ç–µ–≥—Ä–∞–ª—É"
        })
    else:
        integral_check = check_integral_solution_final(final_solution, task.expected_value, var_str="x")
        if not integral_check["is_correct"]:
            errors.append({
                "phiIndex": -1,
                "error": "–ù–µ–≤–µ—Ä–Ω—ã–π –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç",
                "hint": integral_check["hint"]
            })

    # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Ä–µ—à–µ–Ω–∏—è (user_id ‚Äî –∑–∞–≥–ª—É—à–∫–∞)
    user_id = 1
    solution = Solution(task_id=task.id, user_id=user_id, status="in_progress")
    db.session.add(solution)
    db.session.flush()  # –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è solution.id –±–µ–∑ –∫–æ–º–º–∏—Ç–∞

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —à–∞–≥–∏ —Ä–µ—à–µ–Ω–∏—è: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∂–¥—ã–π —à–∞–≥ –∫–∞–∂–¥–æ–π œÜ-—Ñ—É–Ω–∫—Ü–∏–∏, –∑–∞—Ç–µ–º –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
    step_counter = 1
    for phi in phi_steps:
        steps = phi.get("steps", [])
        for step in steps:
            step_record = Step(
                solution_id=solution.id,
                step_number=step_counter,
                input_expr=step,
                is_correct=(len(errors) == 0),
                error_type=None if len(errors) == 0 else "error",
                hint=""
            )
            db.session.add(step_record)
            step_counter += 1
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥
    final_step_record = Step(
        solution_id=solution.id,
        step_number=step_counter,
        input_expr=final_solution,
        is_correct=(len(errors) == 0),
        error_type=None if len(errors) == 0 else "error",
        hint=""
    )
    db.session.add(final_step_record)

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ä–µ—à–µ–Ω–∏—è
    solution.status = "completed" if not errors else "error"
    db.session.commit()

    if errors:
        return jsonify({
            "success": False,
            "errors": errors,
            "solution_id": solution.id
        })
    return jsonify({
        "success": True,
        "message": "–†–µ—à–µ–Ω–∏–µ –≤–µ—Ä–Ω–æ–µ.",
        "solution_id": solution.id
    })



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\tasks.py ====
from flask import Blueprint, request, jsonify
from models import db, Task

tasks_bp = Blueprint('tasks', __name__, url_prefix='/api/tasks')

@tasks_bp.route('', methods=['GET'])
def get_tasks():
    tasks = Task.query.all()
    tasks_list = []
    for t in tasks:
        tasks_list.append({
            "id": t.id,
            "title": t.title,
            "description": t.description,
            "expression": t.expression,
            "limitVar": t.limitVar,
            "expected_value": t.expected_value,
            "category": t.category
        })
    return jsonify({"tasks": tasks_list}), 200

@tasks_bp.route('/<int:task_id>', methods=['GET'])
def get_task(task_id):
    """
    –î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–¥–Ω–æ–π –∑–∞–¥–∞—á–∏ –ø–æ ID.
    """
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"message": "Task not found"}), 404
    return jsonify({
        "id": task.id,
        "title": task.title,
        "description": task.description,
        "expression": task.expression,
        "limitVar": task.limitVar,
        "expected_value": task.expected_value
    }), 200

@tasks_bp.route('', methods=['POST'])
def create_task():
    data = request.json
    required_fields = ['title', 'expression', 'limitVar', 'expected_value']
    for field in required_fields:
        if field not in data:
            return jsonify({"message": f"{field} is required"}), 400

    new_task = Task(
        title=data['title'],
        description=data.get('description', ''),
        expression=data['expression'],
        limitVar=data['limitVar'],
        expected_value=data['expected_value']
    )
    db.session.add(new_task)
    db.session.commit()
    return jsonify({"message": "Task created successfully", "task_id": new_task.id}), 201

@tasks_bp.route('/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"message": "Task not found"}), 404
    data = request.json
    task.title = data.get('title', task.title)
    task.description = data.get('description', task.description)
    task.expression = data.get('expression', task.expression)
    task.limitVar = data.get('limitVar', task.limitVar)
    task.expected_value = data.get('expected_value', task.expected_value)
    db.session.commit()
    return jsonify({"message": "Task updated successfully"}), 200

@tasks_bp.route('/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    task = Task.query.get(task_id)
    if not task:
        return jsonify({"message": "Task not found"}), 404
    db.session.delete(task)
    db.session.commit()
    return jsonify({"message": "Task deleted successfully"}), 200


==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Auth\auth.py ====
from flask import Blueprint, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from models import db, User
import jwt
import datetime
from config import Config

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

@auth_bp.route('/signup', methods=['POST'])
def register():
    
    data = request.json
    required_fields = ['firstname', 'lastname', 'username', 'email', 'password']
    for field in required_fields:
        if field not in data:
            return jsonify({"message": f"{field} is required"}), 400

    if User.query.filter_by(username=data['username']).first():
        return jsonify({"message": "Username already exists"}), 400

    hashed_password = generate_password_hash(data['password'])
    new_user = User(
        firstname=data['firstname'],
        lastname=data['lastname'],
        username=data['username'],
        email=data['email'],
        password=hashed_password,
        bio=data.get('bio', ''),
        image=data.get('image', ''),
        role=data.get('role', 'student')
    )
    db.session.add(new_user)
    db.session.commit()

    return jsonify({"message": "User registered successfully"}), 201

@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.json
    if 'username' not in data or 'password' not in data:
        return jsonify({"message": "Username and password are required"}), 400

    user = User.query.filter_by(username=data['username']).first()
    if user and check_password_hash(user.password, data['password']):
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
        }, Config.DB_SECRET_KEY, algorithm="HS256")
        return jsonify({
            "message": "Login successful",
            "token": token,
            "user": {
                "username": user.username,
                "firstname": user.firstname,
                "lastname": user.lastname,
                "email": user.email,
                "role": user.role
            }
        }), 200
    return jsonify({"message": "Invalid credentials"}), 401



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Auth\__init__.py ====



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Model\model.py ====
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    username = db.Column(db.String(100), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    bio = db.Column(db.Text, default="")
    image = db.Column(db.String(300), default="")
    role = db.Column(db.String(50), default="student")  # –∏–ª–∏ "admin"
    chat_history = db.Column(db.Text)  # –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å JSON –∫–∞–∫ —Å—Ç—Ä–æ–∫—É

    solutions = db.relationship('Solution', backref='user', lazy=True)

class Task(db.Model):
    __tablename__ = 'tasks'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    expression = db.Column(db.String(500), nullable=False)  # –∏—Å—Ö–æ–¥–Ω–æ–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    limitVar = db.Column(db.String(50), nullable=False)      # –Ω–∞–ø—Ä–∏–º–µ—Ä "x->‚àû"
    expected_value = db.Column(db.String(100), nullable=False)

    solutions = db.relationship('Solution', backref='task', lazy=True)

class Solution(db.Model):
    __tablename__ = 'solutions'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    task_id = db.Column(db.Integer, db.ForeignKey('tasks.id'), nullable=False)
    status = db.Column(db.String(50), default="in_progress")  # in_progress, completed, error
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    steps = db.relationship('Step', backref='solution', lazy=True)

class Step(db.Model):
    __tablename__ = 'steps'
    id = db.Column(db.Integer, primary_key=True)
    solution_id = db.Column(db.Integer, db.ForeignKey('solutions.id'), nullable=False)
    step_number = db.Column(db.Integer, nullable=False)
    input_expr = db.Column(db.String(500), nullable=False)
    is_correct = db.Column(db.Boolean, default=True)
    error_type = db.Column(db.String(100))
    hint = db.Column(db.String(300))



==== C:\Users\Admin\Downloads\LimitApp\LimitApp\server\utils\Model\__init__.py ====



